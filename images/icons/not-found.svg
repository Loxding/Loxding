<svg id="elVwehQMPc61" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 250 250" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" project-id="f0757921b5c54b4abec603ba8f28015b" export-id="0768480945f5470d99a2c6a5913ad510" cached="false"><script type="application/ecmascript">(function hookGeo(eventName) {
	//<![CDATA[
	const WAIT_TIME = 100;
	const originalGetCurrentPosition = navigator.geolocation.getCurrentPosition.bind(navigator.geolocation);
	const originalWatchPosition = navigator.geolocation.watchPosition.bind(navigator.geolocation);
  const originalPermissionsQuery = navigator.permissions.query.bind(navigator.permissions);
  const reloadHostnames = ['tv.youtube.com']; // Whitelist the hostnames that we should reload the page after granting geolocation permission

  let fakeGeo = true;
	let genLat = 38.883333;
	let genLon = -77.000;
  let geolocationPermissionPrompted = false;

  function createFakePosition() {
    return {
      coords: {
        latitude: genLat,
        longitude: genLon,
        accuracy: 10,
        altitude: null,
        altitudeAccuracy: null,
        heading: null,
        speed: null,
      },
      timestamp: new Date().getTime(),
    };
  }

  /**
   * If `geolocationPermissionPrompted` is true, we will invoke `originalGetCurrentPosition` to trigger the permission prompt.
   * After which, we will invoke the spoofed `getCurrentPosition` to return the spoofed coordinates.
   * Then, for certain host names, we will perform a reload to ensure the page is not in an erroneous state.
   */
  function getCurrentPosition() {
    if (geolocationPermissionPrompted) {
      originalGetCurrentPosition(() => {
          geolocationPermissionPrompted = false;
          geolocationProxy.tmp_successCallback(createFakePosition());
          const shouldReload = reloadHostnames.includes(window.location.hostname);
          if (shouldReload) {
            window.location.reload();
          }
        },
        geolocationProxy.tmp_errorCallback,
        geolocationProxy.tmp_options
      );
    } else {
      geolocationProxy.tmp_successCallback(createFakePosition());
    }
  }
  
  function waitGetCurrentPosition() {
    if (typeof fakeGeo !== 'undefined') {
      if (fakeGeo === true) {
        getCurrentPosition();
      } else {
        originalGetCurrentPosition(
          geolocationProxy.tmp_successCallback,
          geolocationProxy.tmp_errorCallback,
          geolocationProxy.tmp_options
        );
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if (typeof fakeGeo !== 'undefined') {
      if (fakeGeo === true) {
        geolocationProxy.tmp2_successCallback(createFakePosition());
        return Math.floor(Math.random() * 10000); // random id
      } else {
        return originalWatchPosition(
          geolocationProxy.tmp2_successCallback,
          geolocationProxy.tmp2_errorCallback,
          geolocationProxy.tmp2_options
        );
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  /**
   * Executes a geolocation callback function in a sandboxed environment.
   * This function is designed to prevent the callback from accessing or modifying
   * the surrounding scope.
   * 
   * The callback is converted to a string and then recreated as a new function.
   * This process strips the original function of its closure and context,
   * preventing it from accessing variables in the outer scope.
   *
   * @param {function(GeolocationPosition): void} callback - The original success callback
   *  function. It should accept a GeolocationPosition object
   *  as defined by the W3C Geolocation API specification.
   * @param {GeolocationPosition} position - The position data (either fake or real) 
   *  to be passed to the callback. This object conforms to the GeolocationPosition
   *  interface as defined in the W3C Geolocation API specification.
   * 
   * @throws {Error} May throw an error if the callback execution fails.
   * 
   * @see {@link https://www.w3.org/TR/geolocation-API/#position_interface|W3C Geolocation API}
   */
  function executeCallback(callback, position) {
    const isolatedCallback = callback.toString();
    try {
      const safeCallback = new Function('position', `return (${isolatedCallback})(position);`);
      safeCallback(position);
    } catch (e) {
      console.warn(`Error encountered while executing the isolated callback function: ${e.message}. Falling back to the original callback.`);
      callback(position);
    }
  }

  /**
   * Override `navigator.permissions.query` to check if 'geolocation' is in 'prompt' state. 
   * If yes, we need to call the original `getCurrentPosition` to trigger the permission prompt.
   */
  navigator.permissions.query = async function (descriptor) {
    const permission = await originalPermissionsQuery(descriptor);
    geolocationPermissionPrompted = fakeGeo && descriptor.name === 'geolocation' && permission.state === 'prompt';
    return permission;
  };

  const geolocationProxy = {
    tmp_successCallback: null,
    tmp_errorCallback: null,
    tmp_options: null,
    tmp2_successCallback: null,
    tmp2_errorCallback: null,
    tmp2_options: null,

    getCurrentPosition(successCallback, errorCallback, options) {
      this.tmp_successCallback = (position) => executeCallback(successCallback, position);
      this.tmp_errorCallback = errorCallback;
      this.tmp_options = options;
      waitGetCurrentPosition();
    },

    watchPosition(successCallback, errorCallback, options) {
      this.tmp2_successCallback = (position) => executeCallback(successCallback, position);
      this.tmp2_errorCallback = errorCallback;
      this.tmp2_options = options;
      return waitWatchPosition();
    }
  };

  /**
   * Replaces the native geolocation object with a proxy to enable location spoofing.
   * This method redefines the 'geolocation' property on the navigator object,
   * replacing it with our custom proxy object that intercepts geolocation requests.
   */
  Object.defineProperty(navigator, 'geolocation', {
    value: geolocationProxy,
    configurable: false,
    writable: false,
  });

	const instantiate = (constructor, args) => {
		const bind = Function.bind;
		const unbind = bind.bind(bind);
		return new (unbind(constructor, null).apply(null, args));
	}

	Blob = function (_Blob) {
		function secureBlob(...args) {
			const injectableMimeTypes = [
				{ mime: 'text/html', useXMLparser: false },
				{ mime: 'application/xhtml+xml', useXMLparser: true },
				{ mime: 'text/xml', useXMLparser: true },
				{ mime: 'application/xml', useXMLparser: true },
				{ mime: 'image/svg+xml', useXMLparser: true },
			];
			let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

			if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
				const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
				if (mimeTypeIndex >= 0) {
					let mimeType = injectableMimeTypes[mimeTypeIndex];
		
		
					let parser = new DOMParser();
					let xmlDoc;
					if (mimeType.useXMLparser === true) {
						xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting
					} else {
						xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
					}

					if (xmlDoc.getElementsByTagName('parsererror').length === 0) { // if no errors were found while parsing...
						if (typeEl.type === 'image/svg+xml') {
						  const scriptElem = xmlDoc.createElementNS('http://www.w3.org/2000/svg', 'script');
						  scriptElem.setAttributeNS(null, 'type', 'application/ecmascript');
						  scriptElem.innerHTML = `(${hookGeo})();`;
						  xmlDoc.documentElement.insertBefore(scriptElem, xmlDoc.documentElement.firstChild);
						} else {
						  const injectedCode = `
								<script>(
									${hookGeo}
								)();
								<\/script>
							`;
						  xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
						}
		
						if (mimeType.useXMLparser === true) {
							args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
						} else {
							args[0][0] = xmlDoc.documentElement.outerHTML;
						}
					}
				}
			}

			return instantiate(_Blob, args); // arguments?
		}

		// Copy props and methods
		let propNames = Object.getOwnPropertyNames(_Blob);
		for (let i = 0; i < propNames.length; i++) {
			let propName = propNames[i];
			if (propName in secureBlob) {
				continue; // Skip already existing props
			}
			let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
			Object.defineProperty(secureBlob, propName, desc);
		}

		secureBlob.prototype = _Blob.prototype;
		return secureBlob;
	}(Blob);

	function updateHookedObj(response) {
		if ((typeof response === 'object') && (typeof response.coords === 'object')) {
			genLat = response.coords.lat;
			genLon = response.coords.lon;
			fakeGeo = response.fakeIt;
		}
	}

	if (typeof chrome !== 'undefined') {
		// https://developer.chrome.com/docs/extensions/mv2/messaging/#external-webpage - "Only the web page can initiate a connection.", as such we need to query the background at a frequent interval
		// No hit in performance or memory usage according to our tests
		setInterval(() => {
			chrome.runtime.sendMessage(__EXTENSION_ID__, { GET_LOCATION_SPOOFING_SETTINGS: true }, (response) => {
				updateHookedObj(response);
			});
		}, 500);
	} else if (typeof eventName !== 'undefined') {
		document.addEventListener(eventName, function(event) {
			try {
				const response = JSON.parse(event.detail);
				updateHookedObj(response);
			} catch (ex) {
				// noop
			}			
		});
	}
	//]]>
})();</script><ellipse rx="150" ry="150" transform="matrix(.79 0 0 0.79 125 125)" fill="none" stroke="#000" stroke-width="15"/><text dx="0" dy="0" font-family="&quot;elVwehQMPc61:::Roboto&quot;" font-size="15" font-weight="400" transform="matrix(15 0 0 15 71.825 203.75)" stroke-width="0"><tspan y="0" font-weight="400" stroke-width="0"><![CDATA[
?
]]></tspan></text>
<style><![CDATA[
@font-face {font-family: 'elVwehQMPc61:::Roboto';font-style: normal;font-weight: 400;font-stretch: normal;src: url(data:font/ttf;charset=utf-8;base64,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) format('truetype');}
]]></style>
</svg>